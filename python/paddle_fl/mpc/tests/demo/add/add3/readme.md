# 三方加法Demo

## 应用场景

三个数据方想要在不暴露自己的原始数据的前提下进行数据的加法。

## 算法原理及整体流程

1. 将三方本地数据按照aby3秘密共享的形式拆分，每方数据分为三份。
2. 将三份数据交给三个不同的计算节点（本demo中的run.sh文件提供了单机模拟三方的示例，实际使用中拆开运行即可）。
3. 三方使用Paddlefl提供的基础运算算子，进行三方联合加法计算。
4. 将秘密共享形式的计算结果交给数据合并方（由于本demo是单机模拟三方，这一步在实际使用中需要自行实现）。
5. 重构计算结果。

## 代码执行过程

1. `python3 data.py` 生成三方原始数据，得到Input-P0.list、Input-P1.list和Input-P2.list。
2. `python3 add2_share.py` 将三方本地数据拆分，得到data_C0_P0.npy、data_C1_P0.npy、data_C2_P0.npy、data_C0_P1.npy、data_C1_P1.npy、data_C2_P1.npy、data_C0_P2.npy、data_C1_P2.npy、data_C2_P2.npy，同时会在命令行打印应当得到的加法计算结果。
3. 在真正的多方运算时需要分发第2步中的秘密数据（本demo不需要这一步）。
4. `python3 flush.py` 清除redis中上一次残留的注册信息，以免下面运行的三方进程连接到错误的地方。
5. `./run.sh` 运行单机模拟三方的脚本执行多方联合计算，logs文件夹中会生成运行日志，同时还会生成结果文件result_C0.npy、result_C1.npy、result_C2.npy。
6. 在真正的多方运算时需要将第5步秘密共享形式的计算结果交给数据合并方（本demo不需要这一步）。
7. `python3 reconstruct.py` 重构计算结果，并在命令行打印实际计算得到的加法结果。

## 其他说明

1. 文件名中C代表计算方的编号，P代表数据方的编号，例如data_C0_P1.npy代表这份秘密来自数据方1，需要交给计算方0。
2. 数据方编号与计算方编号均由0开始。
3. 和paddlefl提供的原始test_op_base.py相比，本demo中注释掉了第70行代码，这一行代码会引起redis注册混乱，从而影响到三方模拟运算；同时将multi_party_run改造成了三个不同的函数，以便三方分别调用单独生成进程。
4. 需要预设好三方加法的数据量大小，该参数为add3_C0.py、add3_C1.py、add3_C2.py中第16行的num。
